# 二叉树

### 前序遍历

二叉树的前中后遍历使用递归方法非常简单，用迭代法需要用到栈，下面python代码栈是列表 `stack` ，储存了二叉树的节点地址信息。大致思想：每一次遍历到一个节点判断是否为根节点，根节点则输出当前值，储存右孩子地址到栈，指向左孩子，重复以上操作，直到遇到叶子节点。

碰到叶子节点，输出当前内容，指针指向栈顶储存的最近的一个右子树的地址：

```python
else:  
    vec.append(root.val)
    if (len(stack) != 0):
        root = stack[-1]
        stack.pop()
    else:    
        root = None
```

有一种情况，当前为叶子节点，但栈为空，就是没有右子树，直接让指针指向`NULL`，`while` 的判断就会中断，遍历完成。

迭代方法二叉树前序遍历（python ver）：

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        vec = []
        if (root == None):
            return vec
        stack = []
        while(root != None or len(stack) != 0):
            if (self.isRoot(root)):
                vec.append(root.val)
                if (root.right != None):
                    stack.append(root.right)
                if (root.left != None):
                    root = root.left
                else:
                    root = stack[-1];
                    stack.pop()
            else: 
                vec.append(root.val)
                if (len(stack) != 0):
                    root = stack[-1]
                    stack.pop()
                else:    
                    root = None
        return vec

    
            
    def isRoot(self, root):
        if (root.left != None or root.right != None):
            return True
        else:
            return False
```

C语言（有点问题，不明白C的要求是返回链表还是数组）：

```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
bool rootisroot(struct TreeNode* root){
    if (root ->left != NULL || root ->right != NULL)
    {
        return true;
    }
    return false;
};

struct stack {
    int top;
    struct TreeNode* arr[100];
};

int* preorderTraversal(struct TreeNode* root, int* returnSize){
    int vec[100];
    if (root == NULL){
        return vec;
    }
    struct stack st;
    st.top = -1;
    vec[0] = 1;
    int i = 0;
    returnSize = &i;
    while (st.top!=-2 && root != NULL)
    {
        if (rootisroot(root))
        {
            vec[i] = root->val;
            i++;
            if (root ->right != NULL)
            {
                st.top++;
                st.arr[st.top] = root->right;
            }
            if (root->left != NULL)
                root = root->left;
            else
                root = st.arr[st.top];
                st.top--;
        }
        else 
        {
            vec[i] = root->val;
            i++;
            root = st.arr[st.top];
            st.top--;
        }
    }
    root = NULL;
    return vec;
}
```

