# 二叉树

### 前序遍历

二叉树的前中后遍历使用递归方法非常简单，用迭代法需要用到栈，下面python代码栈是列表 `stack` ，储存了二叉树的节点地址信息。大致思想：每一次遍历到一个节点判断是否为根节点，根节点则输出当前值，储存右孩子地址到栈，指向左孩子，重复以上操作，直到遇到叶子节点。

碰到叶子节点，输出当前内容，指针指向栈顶储存的最近的一个右子树的地址：

```python
else:  
    vec.append(root.val)
    if (len(stack) != 0):
        root = stack[-1]
        stack.pop()
    else:    
        root = None
```

有一种情况，当前为叶子节点，但栈为空，就是没有右子树，直接让指针指向`NULL`，`while` 的判断就会中断，遍历完成。

迭代方法二叉树前序遍历（python ver）：

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        vec = []
        if (root == None):
            return vec
        stack = []
        while(root != None or len(stack) != 0):
            if (self.isRoot(root)):
                vec.append(root.val)
                if (root.right != None):
                    stack.append(root.right)
                if (root.left != None):
                    root = root.left
                else:
                    root = stack[-1];
                    stack.pop()
            else: 
                vec.append(root.val)
                if (len(stack) != 0):
                    root = stack[-1]
                    stack.pop()
                else:    
                    root = None
        return vec

    
            
    def isRoot(self, root):
        if (root.left != None or root.right != None):
            return True
        else:
            return False
```

C语言，**注意**传给 `returnSize`的是一个记录数据长度的整形 `int` 数据的地址：

```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
bool rootisroot(struct TreeNode* root){
    if (root ->left != NULL || root ->right != NULL)
    {
        return true;
    }
    return false;
};
//define a stack
struct stack {
    int top;
    struct TreeNode* arr[100];
};

int* preorderTraversal(struct TreeNode* root, int* returnSize){
    int * vec = (int *)malloc(100*sizeof(int));
    int i = 0;
    if (root == NULL){
        *returnSize = i;
        return vec;
    }
    struct stack st;
    st.top = -1;
    //returnSize = &i; //错误写法
    while (st.top!=-1 || root != NULL)
    {
        if (rootisroot(root))
        {
            vec[i] = root->val;
            i++;
            if (root ->right != NULL)
            {
                st.top++;
                st.arr[st.top] = root->right;
            }
            if (root->left != NULL)
                root = root->left;
            else
            {
                root = st.arr[st.top];
                st.top--;
            }

        }
        else 
        {
            if (st.top == -1)
            {
                vec[i] = root->val;
                i++;
                root = NULL;
            }
            else
            {
                vec[i] = root->val;
                i++;
                root = st.arr[st.top];
                st.top--;
            }

        }
    }
    *returnSize = i;
    return vec;
}
```

### 中序遍历：

直接放C版本，代码比较冗长，或许不是一个比较好的迭代写法，但是好处在于思想和前序遍历差不多，这次栈内记录根节点的地址，上面是记录根节点右孩子的地址。

```C
bool rootisroot(struct TreeNode* root){
    if (root ->left != NULL || root ->right != NULL)
    {
        return true;
    }
    return false;
};

struct stack {
    int top;
    struct TreeNode* arr[100];
};

int* inorderTraversal(struct TreeNode* root, int* returnSize){
    int * vec = (int *)malloc(100*sizeof(int));
    int i = 0;
    if (root == NULL){
        *returnSize = i;
        return vec;
    }
    struct stack st;
    st.top = -1;

    while (st.top!=-1 || root != NULL)
    {
        if (root == NULL)                      //whether is null or not, if is null and the stack is not empty, the pointer 													//point to stack's top
        {
            root = st.arr[st.top]->right;
            vec[i] = st.arr[st.top]->val;
            i++;
            st.top--;
        }  
        else if (rootisroot(root))   //is root
        {

            if (root ->left!= NULL)
            {
                st.top++;
                st.arr[st.top] = root;  //push
                root = root->left;
            }
            else
            {
            	vec[i] = root->val;
                i++;
                root = root->right;
			}

        }
        else    //is leaf
        {
            if (st.top!=-1)   //the stack is not null.
            {
                vec[i] = root->val;
                i++;
                vec[i] = st.arr[st.top]->val;
                i++;
                root = st.arr[st.top]->right;
                st.top--;        
            }
            else              //this is important, if there is only one node
            {
                vec[i] = root->val;
                i++;
                root = NULL;
            }

        }
    }
    *returnSize = i;
    return vec;
}
```

