# 二叉树

### 前序遍历

二叉树的前中后遍历使用递归方法非常简单，用迭代法需要用到栈，下面python代码栈是列表 `stack` ，储存了二叉树的节点地址信息。大致思想：每一次遍历到一个节点判断是否为根节点，根节点则输出当前值，储存右孩子地址到栈，指向左孩子，重复以上操作，直到遇到叶子节点。

碰到叶子节点，输出当前内容，指针指向栈顶储存的最近的一个右子树的地址：

```python
else:  
    vec.append(root.val)
    if (len(stack) != 0):
        root = stack[-1]
        stack.pop()
    else:    
        root = None
```

有一种情况，当前为叶子节点，但栈为空，就是没有右子树，直接让指针指向`NULL`，`while` 的判断就会中断，遍历完成。

迭代方法二叉树前序遍历（python ver）：

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        vec = []
        if (root == None):
            return vec
        stack = []
        while(root != None or len(stack) != 0):
            if (self.isRoot(root)):
                vec.append(root.val)
                if (root.right != None):
                    stack.append(root.right)
                if (root.left != None):
                    root = root.left
                else:
                    root = stack[-1];
                    stack.pop()
            else: 
                vec.append(root.val)
                if (len(stack) != 0):
                    root = stack[-1]
                    stack.pop()
                else:    
                    root = None
        return vec

    
            
    def isRoot(self, root):
        if (root.left != None or root.right != None):
            return True
        else:
            return False
```

C语言，**注意**传给 `returnSize`的是一个记录数据长度的整形 `int` 数据的地址：

```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
bool rootisroot(struct TreeNode* root){
    if (root ->left != NULL || root ->right != NULL)
    {
        return true;
    }
    return false;
};
//define a stack
struct stack {
    int top;
    struct TreeNode* arr[100];
};

int* preorderTraversal(struct TreeNode* root, int* returnSize){
    int * vec = (int *)malloc(100*sizeof(int));
    int i = 0;
    if (root == NULL){
        *returnSize = i;
        return vec;
    }
    struct stack st;
    st.top = -1;
    //returnSize = &i; //错误写法
    while (st.top!=-1 || root != NULL)
    {
        if (rootisroot(root))
        {
            vec[i] = root->val;
            i++;
            if (root ->right != NULL)
            {
                st.top++;
                st.arr[st.top] = root->right;
            }
            if (root->left != NULL)
                root = root->left;
            else
            {
                root = st.arr[st.top];
                st.top--;
            }

        }
        else 
        {
            if (st.top == -1)
            {
                vec[i] = root->val;
                i++;
                root = NULL;
            }
            else
            {
                vec[i] = root->val;
                i++;
                root = st.arr[st.top];
                st.top--;
            }

        }
    }
    *returnSize = i;
    return vec;
}
```

### 中序遍历

直接放C版本，代码比较冗长，或许不是一个比较好的迭代写法，但是好处在于思想和前序遍历差不多，这次栈内记录根节点的地址，上面是记录根节点右孩子的地址。

```C
bool rootisroot(struct TreeNode* root){
    if (root ->left != NULL || root ->right != NULL)
    {
        return true;
    }
    return false;
};

struct stack {
    int top;
    struct TreeNode* arr[100];
};

int* inorderTraversal(struct TreeNode* root, int* returnSize){
    int * vec = (int *)malloc(100*sizeof(int));
    int i = 0;
    if (root == NULL){
        *returnSize = i;
        return vec;
    }
    struct stack st;
    st.top = -1;

    while (st.top!=-1 || root != NULL)
    {
        if (root == NULL)                      //whether is null or not, if is null and the stack is not empty, the pointer 													//point to stack's top
        {
            root = st.arr[st.top]->right;
            vec[i] = st.arr[st.top]->val;
            i++;
            st.top--;
        }  
        else if (rootisroot(root))   //is root
        {

            if (root ->left!= NULL)
            {
                st.top++;
                st.arr[st.top] = root;  //push
                root = root->left;
            }
            else
            {
            	vec[i] = root->val;
                i++;
                root = root->right;
			}

        }
        else    //is leaf
        {
            if (st.top!=-1)   //the stack is not null.
            {
                vec[i] = root->val;
                i++;
                vec[i] = st.arr[st.top]->val;
                i++;
                root = st.arr[st.top]->right;
                st.top--;        
            }
            else              //this is important, if there is only one node
            {
                vec[i] = root->val;
                i++;
                root = NULL;
            }

        }
    }
    *returnSize = i;
    return vec;
}
```

### 二叉树层序遍历

**示例：**
二叉树：`[3,9,20,null,null,15,7]`,

返回其层序遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

#### 队列

迭代法加递归法，迭代法需要用到`队列` ，首先回顾队列的特性：1、受限制线性表；2、先进先出（FIFO）；3、两个指针：`rear` 指向队列尾部元素，`front` 指向首部元素；

实际上顺序队列有两个缺点：1. 如果固定前n个位置储存元素，则删除一个元素后面的需要向前移动，操作代价为 $\Theta(n)$ ，2 . 如果不需要维持这个条件，随着`font` 指针增加，队列剩余空间会越来越少，造成假溢出（前面还有空间）。

为解决前两个问题，可以采用循环队列，实际上是假定数组是循环。判断队空或队满会出现矛盾，当`rear ` 在 `font ` 前，既是队空也是队满的表现。因此实现队列的实际大小时可以是默认大小加1，`size+1` 。

这种方式可区分队空队满：1、`(rear+2) % maxsize = front`则 队满，2、`(rear+1) % maxsize = front`为空 `maxsize ` 为队列长度size+1，`rear` 和 `font` 取值从0开始。`front` 初始化为0,即是队首，`rear`初始化为`maxsize-1`即队列最后元素下标

用python实现的循环队列如下：

```python
class queue():
    def __init__(self,size,root):
        self.que = []
        self.maxSize = size+1
        for i in range(self.maxSize):      #我的理解队列是数组，事先分配好一定内存的数组,注意数组预定大小是size+1，之前一直跑不通因为用了size
            self.que.append(root)
        
        self.front = 0
        self.rear = self.maxSize-1

    def enqueue(self,val):
        self.que[(self.rear+1) % self.maxSize] = val
        self.rear = (self.rear+1) % self.maxSize

    def dequeue(self):
        temp = self.que[(self.front) % self.maxSize]
        self.front = (self.front+1) % self.maxSize
        return temp

    def isEmpty(self):
        if ((self.rear+1) % self.maxSize == self.front):
            return True
        else:
            return False

    def isFull(self):
        if ((self.rear+2)% self.maxSize == self.front):
            return True
        else:
            return False
        
    def queueSize(self):     #计算队列大小
        if (self.rear >= self.front):
            size = self.rear - self.front + 1
        else:
            size = self.maxSize - self.front + self.rear + 1  
        return size
```

层序遍历：

- enqueue root

- compute the size of queue

- dequeue the roots in the queue, enqueue the left child and right child of each root.

  解答：

  [1]: https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-ceng-xu-bian-li-deng-chang-wo-yao-da-sh/	"代码随想录"

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        arr = []
        Q = queue(140,root)
        if (root == None):
            return arr
        else:
            Q.enqueue(root)

        while (Q.isEmpty() == False):
            element = []
            size = Q.queueSize()
            for i in range(size):
                it = Q.dequeue()
                element.append(it.val)
                if (it.left != None and not Q.isFull()):
                    Q.enqueue(it.left)
                if (it.right != None and not Q.isFull()):
                    Q.enqueue(it.right)

            arr.append(element)
        return arr
```

实际上python的写法可以非常简洁，队列可以用列表实现，出队直接`pop(0)`，上面重复造轮子，算是复习一遍基本数据结构吧。

#### 递归写法

引用某湖南大学老师的总结：

- 递归出口

- 递归体

  貌似需要计算树高度。递归在这里并不是一种很好的做法。

### 二叉树反转

针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。

翻转一棵二叉树（226）。

示例：

输入：

     	  4
        /   \
      2     7
     / \   / \
    1   3 6   9

输出：

          4
        /   \
      7     2
     / \   / \
    9   6 3   1
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

bool rootisroot(struct TreeNode* root){
    if (root ->left != NULL || root ->right != NULL)
    {
        return true;
    }
    return false;
};

struct TreeNode* invertTree(struct TreeNode* root){
    struct TreeNode * temp = NULL;
    if (root == NULL)
    {
        return root;
    }
    else if (rootisroot)   //其实不需要判断是否为叶子
    {
        temp = root->left;
        root -> left = root -> right;
        root->right = temp;
        invertTree(root->left);
        invertTree(root->right);
    }
    return root;           //这一步return比较重要，因为最后要返回第一层的根节点
}
```

以上写法为前序遍历，除了中序遍历，其他遍历方法都可以用。

